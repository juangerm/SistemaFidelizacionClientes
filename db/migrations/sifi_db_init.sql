-- DROP SCHEMA public;

CREATE SCHEMA public AUTHORIZATION pg_database_owner;

-- DROP SEQUENCE public.bolsapunto_id_seq;

CREATE SEQUENCE public.bolsapunto_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.bolsapunto_id_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.bolsapunto_id_seq TO postgres;

-- DROP SEQUENCE public.cliente_id_seq;

CREATE SEQUENCE public.cliente_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.cliente_id_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.cliente_id_seq TO postgres;

-- DROP SEQUENCE public.conceptopunto_id_seq;

CREATE SEQUENCE public.conceptopunto_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.conceptopunto_id_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.conceptopunto_id_seq TO postgres;

-- DROP SEQUENCE public.nacionalidades_cod_nacionalidad_seq;

CREATE SEQUENCE public.nacionalidades_cod_nacionalidad_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.nacionalidades_cod_nacionalidad_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.nacionalidades_cod_nacionalidad_seq TO postgres;

-- DROP SEQUENCE public.paises_cod_pais_seq;

CREATE SEQUENCE public.paises_cod_pais_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.paises_cod_pais_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.paises_cod_pais_seq TO postgres;

-- DROP SEQUENCE public.reglaasignacionpunto_id_seq;

CREATE SEQUENCE public.reglaasignacionpunto_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.reglaasignacionpunto_id_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.reglaasignacionpunto_id_seq TO postgres;

-- DROP SEQUENCE public.tipos_documentos_cod_tipo_documento_seq;

CREATE SEQUENCE public.tipos_documentos_cod_tipo_documento_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.tipos_documentos_cod_tipo_documento_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.tipos_documentos_cod_tipo_documento_seq TO postgres;

-- DROP SEQUENCE public.usopuntocabecera_id_seq;

CREATE SEQUENCE public.usopuntocabecera_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.usopuntocabecera_id_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.usopuntocabecera_id_seq TO postgres;

-- DROP SEQUENCE public.usopuntodetalle_id_seq;

CREATE SEQUENCE public.usopuntodetalle_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.usopuntodetalle_id_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.usopuntodetalle_id_seq TO postgres;

-- DROP SEQUENCE public.vencimientopunto_id_seq;

CREATE SEQUENCE public.vencimientopunto_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;

-- Permissions

ALTER SEQUENCE public.vencimientopunto_id_seq OWNER TO postgres;
GRANT ALL ON SEQUENCE public.vencimientopunto_id_seq TO postgres;
-- public.conceptopunto definition

-- Drop table

-- DROP TABLE public.conceptopunto;

CREATE TABLE public.conceptopunto (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	concepto varchar(255) NULL,
	punto_requerido int4 NULL,
	CONSTRAINT conceptopunto_pkey PRIMARY KEY (id)
);

-- Table Triggers

create trigger trg_conceptopunto_validate before
insert
    or
update
    on
    public.conceptopunto for each row execute function trg_conceptopunto_validate();
create trigger trg_00_upcase_conceptopunto before
insert
    or
update
    on
    public.conceptopunto for each row execute function trg_upcase_conceptopunto();

-- Permissions

ALTER TABLE public.conceptopunto OWNER TO postgres;
GRANT ALL ON TABLE public.conceptopunto TO postgres;


-- public.images definition

-- Drop table

-- DROP TABLE public.images;

CREATE TABLE public.images (
	id varchar(32) NOT NULL,
	gallery varchar(32) NULL,
	image bytea NULL,
	CONSTRAINT images_pkey PRIMARY KEY (id)
);

-- Permissions

ALTER TABLE public.images OWNER TO postgres;
GRANT ALL ON TABLE public.images TO postgres;


-- public.oxdiscussioncomments definition

-- Drop table

-- DROP TABLE public.oxdiscussioncomments;

CREATE TABLE public.oxdiscussioncomments (
	id varchar(32) NOT NULL,
	"comment" oid NULL,
	discussionid varchar(32) NULL,
	"time" timestamp NULL,
	username varchar(30) NULL,
	CONSTRAINT oxdiscussioncomments_pkey PRIMARY KEY (id)
);
CREATE INDEX idxbhlx4vunn24ym1tbrlgq8g30m ON public.oxdiscussioncomments USING btree (discussionid);

-- Permissions

ALTER TABLE public.oxdiscussioncomments OWNER TO postgres;
GRANT ALL ON TABLE public.oxdiscussioncomments TO postgres;


-- public.paises definition

-- Drop table

-- DROP TABLE public.paises;

CREATE TABLE public.paises (
	cod_pais int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	abreviatura varchar(2) NULL,
	descripcion varchar(255) NULL,
	CONSTRAINT paises_pkey PRIMARY KEY (cod_pais)
);

-- Table Triggers

create trigger trg_00_upcase_paises before
insert
    or
update
    on
    public.paises for each row execute function trg_upcase_paises();

-- Permissions

ALTER TABLE public.paises OWNER TO postgres;
GRANT ALL ON TABLE public.paises TO postgres;


-- public.reglaasignacionpunto definition

-- Drop table

-- DROP TABLE public.reglaasignacionpunto;

CREATE TABLE public.reglaasignacionpunto (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	limite_inferior int4 NULL,
	limite_superior int4 NULL,
	monto_equivalente int4 NULL,
	punto_equivalente int4 NULL,
	CONSTRAINT reglaasignacionpunto_pkey PRIMARY KEY (id)
);

-- Table Triggers

create trigger trg_regla_validate before
insert
    or
update
    on
    public.reglaasignacionpunto for each row execute function trg_regla_validate();

-- Permissions

ALTER TABLE public.reglaasignacionpunto OWNER TO postgres;
GRANT ALL ON TABLE public.reglaasignacionpunto TO postgres;


-- public.tipos_documentos definition

-- Drop table

-- DROP TABLE public.tipos_documentos;

CREATE TABLE public.tipos_documentos (
	cod_tipo_documento int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	descripcion varchar(255) NULL,
	CONSTRAINT tipos_documentos_pkey PRIMARY KEY (cod_tipo_documento)
);

-- Table Triggers

create trigger trg_00_upcase_tipos_documentos before
insert
    or
update
    on
    public.tipos_documentos for each row execute function trg_upcase_tipos_documentos();

-- Permissions

ALTER TABLE public.tipos_documentos OWNER TO postgres;
GRANT ALL ON TABLE public.tipos_documentos TO postgres;


-- public.vencimientopunto definition

-- Drop table

-- DROP TABLE public.vencimientopunto;

CREATE TABLE public.vencimientopunto (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	dias_validez int4 NULL,
	fecha_fin date NULL,
	fecha_inicio date NULL,
	CONSTRAINT vencimientopunto_pkey PRIMARY KEY (id)
);

-- Table Triggers

create trigger trg_vencimientopunto_validate before
insert
    or
update
    on
    public.vencimientopunto for each row execute function trg_vencimientopunto_validate();

-- Permissions

ALTER TABLE public.vencimientopunto OWNER TO postgres;
GRANT ALL ON TABLE public.vencimientopunto TO postgres;


-- public.nacionalidades definition

-- Drop table

-- DROP TABLE public.nacionalidades;

CREATE TABLE public.nacionalidades (
	cod_nacionalidad int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	nacionalidad varchar(255) NULL,
	cod_pais int4 NULL,
	CONSTRAINT nacionalidades_pkey PRIMARY KEY (cod_nacionalidad),
	CONSTRAINT fk_nacionalidad_pais FOREIGN KEY (cod_pais) REFERENCES public.paises(cod_pais)
);

-- Table Triggers

create trigger trg_00_upcase_nacionalidades before
insert
    or
update
    on
    public.nacionalidades for each row execute function trg_upcase_nacionalidades();

-- Permissions

ALTER TABLE public.nacionalidades OWNER TO postgres;
GRANT ALL ON TABLE public.nacionalidades TO postgres;


-- public.cliente definition

-- Drop table

-- DROP TABLE public.cliente;

CREATE TABLE public.cliente (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	apellido varchar(255) NULL,
	celular varchar(255) NULL,
	email varchar(255) NULL,
	fecha_nacimiento date NULL,
	nombre varchar(255) NULL,
	numero_documento varchar(12) NULL,
	cod_nacionalidad int4 NULL,
	cod_tipo_documento int4 NULL,
	CONSTRAINT cliente_pkey PRIMARY KEY (id),
	CONSTRAINT uq_cliente_doc UNIQUE (cod_tipo_documento, numero_documento),
	CONSTRAINT fk_cliente_tipodocumento FOREIGN KEY (cod_tipo_documento) REFERENCES public.tipos_documentos(cod_tipo_documento),
	CONSTRAINT fk_persona_nacionalidad FOREIGN KEY (cod_nacionalidad) REFERENCES public.nacionalidades(cod_nacionalidad)
);

-- Table Triggers

create trigger trg_cliente_validate before
insert
    or
update
    on
    public.cliente for each row execute function trg_cliente_validate();
create trigger trg_00_upcase_cliente before
insert
    or
update
    on
    public.cliente for each row execute function trg_upcase_cliente();

-- Permissions

ALTER TABLE public.cliente OWNER TO postgres;
GRANT ALL ON TABLE public.cliente TO postgres;


-- public.usopuntocabecera definition

-- Drop table

-- DROP TABLE public.usopuntocabecera;

CREATE TABLE public.usopuntocabecera (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	fecha date NULL,
	puntaje_utilizado int4 NULL,
	idcliente int4 NULL,
	idconceptopunto int4 NULL,
	CONSTRAINT usopuntocabecera_pkey PRIMARY KEY (id),
	CONSTRAINT fk_bolsapunto_cliente FOREIGN KEY (idcliente) REFERENCES public.cliente(id),
	CONSTRAINT fk_usopuntocabecera_conceptopunto FOREIGN KEY (idconceptopunto) REFERENCES public.conceptopunto(id)
);
CREATE INDEX idx_cab_by_cliente ON public.usopuntocabecera USING btree (idcliente);

-- Table Triggers

create trigger trg_usopuntocabecera_validate before
insert
    on
    public.usopuntocabecera for each row execute function trg_usopuntocabecera_validate();
create trigger trg_usopuntocabecera_refund before
delete
    on
    public.usopuntocabecera for each row execute function trg_usopuntocabecera_refund_exact();
create trigger trg_usopuntocabecera_revert before
delete
    on
    public.usopuntocabecera for each row execute function trg_usopuntocabecera_revert();

-- Permissions

ALTER TABLE public.usopuntocabecera OWNER TO postgres;
GRANT ALL ON TABLE public.usopuntocabecera TO postgres;


-- public.bolsapunto definition

-- Drop table

-- DROP TABLE public.bolsapunto;

CREATE TABLE public.bolsapunto (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	monto_operacion numeric(19, 2) NULL,
	puntaje_asignado int4 NULL,
	puntaje_utilizado int4 NULL,
	saldo_punto int4 NULL,
	idcliente int4 NULL,
	idvencimientopunto int4 NULL,
	CONSTRAINT bolsapunto_pkey PRIMARY KEY (id),
	CONSTRAINT fk_bolsapunto_cliente FOREIGN KEY (idcliente) REFERENCES public.cliente(id),
	CONSTRAINT fk_bolsapunto_vencimientopunto FOREIGN KEY (idvencimientopunto) REFERENCES public.vencimientopunto(id)
);
CREATE INDEX idx_bolsa_by_cliente ON public.bolsapunto USING btree (idcliente);
CREATE INDEX idx_bolsa_by_venc ON public.bolsapunto USING btree (idvencimientopunto);

-- Table Triggers

create trigger trg_bolsapunto_integridad before
insert
    or
update
    on
    public.bolsapunto for each row execute function trg_bolsapunto_calc();

-- Permissions

ALTER TABLE public.bolsapunto OWNER TO postgres;
GRANT ALL ON TABLE public.bolsapunto TO postgres;


-- public.usopuntodetalle definition

-- Drop table

-- DROP TABLE public.usopuntodetalle;

CREATE TABLE public.usopuntodetalle (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	idbolsapunto int4 NULL,
	idusopuntocabecera int4 NULL,
	puntos_consumidos int4 NOT NULL,
	CONSTRAINT chk_usopuntodetalle_puntos_pos CHECK ((puntos_consumidos >= 0)),
	CONSTRAINT usopuntodetalle_pkey PRIMARY KEY (id),
	CONSTRAINT fk_usopuntodetalle_idbolsapunto FOREIGN KEY (idbolsapunto) REFERENCES public.bolsapunto(id),
	CONSTRAINT fk_usopuntodetalle_idusopuntocabecera FOREIGN KEY (idusopuntocabecera) REFERENCES public.usopuntocabecera(id)
);
CREATE INDEX idx_usodet_by_cab ON public.usopuntodetalle USING btree (idusopuntocabecera);

-- Table Triggers

create trigger trg_usopuntodetalle_validate before
insert
    on
    public.usopuntodetalle for each row execute function trg_usopuntodetalle_validate();

-- Permissions

ALTER TABLE public.usopuntodetalle OWNER TO postgres;
GRANT ALL ON TABLE public.usopuntodetalle TO postgres;



-- DROP FUNCTION public.fn_calc_puntos_por_monto(numeric);

CREATE OR REPLACE FUNCTION public.fn_calc_puntos_por_monto(p_monto numeric)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_monto_equiv    integer;
  v_punto_equiv    integer;
  v_puntos         integer := 0;
BEGIN
  IF p_monto IS NULL OR p_monto <= 0 THEN
    RETURN 0;
  END IF;

  SELECT r.monto_equivalente, r.punto_equivalente
    INTO v_monto_equiv, v_punto_equiv
  FROM reglaasignacionpunto r
  WHERE (r.limite_inferior IS NULL OR p_monto >= r.limite_inferior)
    AND (r.limite_superior IS NULL OR p_monto <= r.limite_superior)
  ORDER BY r.limite_inferior DESC NULLS LAST
  LIMIT 1;

  IF v_monto_equiv IS NULL OR v_monto_equiv <= 0 OR v_punto_equiv IS NULL OR v_punto_equiv <= 0 THEN
    RETURN 0;
  END IF;

  v_puntos := floor(p_monto / v_monto_equiv) * v_punto_equiv;
  IF v_puntos < 0 THEN v_puntos := 0; END IF;

  RETURN v_puntos;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.fn_calc_puntos_por_monto(numeric) OWNER TO postgres;
GRANT ALL ON FUNCTION public.fn_calc_puntos_por_monto(numeric) TO postgres;

-- DROP FUNCTION public.fn_is_valid_email(text);

CREATE OR REPLACE FUNCTION public.fn_is_valid_email(p_email text)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF p_email IS NULL THEN
    RETURN FALSE;
  END IF;
  -- Regex simple: algo@algo.algo (sin cubrir todos los casos RFC)
  RETURN p_email ~ '^[A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}$';
END;
$function$
;

-- Permissions

ALTER FUNCTION public.fn_is_valid_email(text) OWNER TO postgres;
GRANT ALL ON FUNCTION public.fn_is_valid_email(text) TO postgres;

-- DROP FUNCTION public.fn_lower_if_not_null(text);

CREATE OR REPLACE FUNCTION public.fn_lower_if_not_null(p text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
  SELECT CASE WHEN $1 IS NULL THEN NULL ELSE lower(btrim($1)) END
$function$
;

-- Permissions

ALTER FUNCTION public.fn_lower_if_not_null(text) OWNER TO postgres;
GRANT ALL ON FUNCTION public.fn_lower_if_not_null(text) TO postgres;

-- DROP FUNCTION public.fn_total_saldo_disponible(int4);

CREATE OR REPLACE FUNCTION public.fn_total_saldo_disponible(p_cliente integer)
 RETURNS integer
 LANGUAGE sql
AS $function$
  SELECT COALESCE(SUM(b.saldo_punto), 0)::int
  FROM bolsapunto b
  LEFT JOIN vencimientopunto v ON v.id = b.idvencimientopunto
  WHERE b.idcliente = p_cliente
    AND b.saldo_punto > 0
    AND (
         v.id IS NULL
         OR v.fecha_fin IS NULL
         OR v.fecha_fin >= current_date
    );
$function$
;

-- Permissions

ALTER FUNCTION public.fn_total_saldo_disponible(int4) OWNER TO postgres;
GRANT ALL ON FUNCTION public.fn_total_saldo_disponible(int4) TO postgres;

-- DROP FUNCTION public.fn_upper_if_not_null(text);

CREATE OR REPLACE FUNCTION public.fn_upper_if_not_null(p text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
  SELECT CASE WHEN $1 IS NULL THEN NULL ELSE upper(btrim($1)) END
$function$
;

-- Permissions

ALTER FUNCTION public.fn_upper_if_not_null(text) OWNER TO postgres;
GRANT ALL ON FUNCTION public.fn_upper_if_not_null(text) TO postgres;

-- DROP FUNCTION public.fn_usar_puntos(int4, int4, int4);

CREATE OR REPLACE FUNCTION public.fn_usar_puntos(p_idcliente integer, p_idconcepto integer, p_puntos integer DEFAULT NULL::integer)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_req int;
  v_ausar int;
  v_dispo int;
  v_idcab int;
  rec record;
  v_chunk int;
BEGIN
  IF p_idcliente IS NULL OR p_idconcepto IS NULL THEN
    RAISE EXCEPTION 'idcliente e idconcepto son obligatorios';
  END IF;

  SELECT punto_requerido INTO v_req
  FROM conceptopunto
  WHERE id = p_idconcepto;

  IF v_req IS NULL OR v_req <= 0 THEN
    RAISE EXCEPTION 'Concepto inválido o sin punto_requerido > 0';
  END IF;

  v_ausar := COALESCE(p_puntos, v_req);
  IF v_ausar <= 0 THEN
    RAISE EXCEPTION 'Cantidad de puntos a usar debe ser > 0';
  END IF;

  v_dispo := fn_total_saldo_disponible(p_idcliente);
  IF v_dispo < v_ausar THEN
    RAISE EXCEPTION 'Saldo insuficiente: disponible %, requerido %', v_dispo, v_ausar;
  END IF;

  -- Crear cabecera
  INSERT INTO usopuntocabecera(fecha, puntaje_utilizado, idcliente, idconceptopunto)
  VALUES (current_date, v_ausar, p_idcliente, p_idconcepto)
  RETURNING id INTO v_idcab;

  -- Consumir FIFO
  FOR rec IN
    SELECT b.id, b.saldo_punto
    FROM bolsapunto b
    LEFT JOIN vencimientopunto v ON v.id = b.idvencimientopunto
    WHERE b.idcliente = p_idcliente
      AND b.saldo_punto > 0
      AND (v.id IS NULL OR v.fecha_fin IS NULL OR v.fecha_fin >= current_date)
    ORDER BY b.id
  LOOP
    EXIT WHEN v_ausar = 0;

    v_chunk := LEAST(rec.saldo_punto, v_ausar);

    -- 1) Registrar el vínculo con la cantidad consumida
    INSERT INTO usopuntodetalle(idbolsapunto, idusopuntocabecera, puntos_consumidos)
    VALUES (rec.id, v_idcab, v_chunk);

    -- 2) Actualizar la bolsa
    UPDATE bolsapunto
       SET puntaje_utilizado = puntaje_utilizado + v_chunk,
           saldo_punto = saldo_punto - v_chunk
     WHERE id = rec.id;

    v_ausar := v_ausar - v_chunk;
  END LOOP;

  IF v_ausar <> 0 THEN
    RAISE EXCEPTION 'Inconsistencia en consumo de puntos (remanente %)', v_ausar;
  END IF;

  RETURN v_idcab;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.fn_usar_puntos(int4, int4, int4) OWNER TO postgres;
GRANT ALL ON FUNCTION public.fn_usar_puntos(int4, int4, int4) TO public;
GRANT ALL ON FUNCTION public.fn_usar_puntos(int4, int4, int4) TO postgres;

-- DROP FUNCTION public.fn_vencer_bolsas();

CREATE OR REPLACE FUNCTION public.fn_vencer_bolsas()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_count int;
BEGIN
  UPDATE bolsapunto b
     SET saldo_punto = 0
    FROM vencimientopunto v
   WHERE v.id = b.idvencimientopunto
     AND v.fecha_fin IS NOT NULL
     AND v.fecha_fin < current_date
     AND b.saldo_punto > 0;

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.fn_vencer_bolsas() OWNER TO postgres;
GRANT ALL ON FUNCTION public.fn_vencer_bolsas() TO postgres;

-- DROP FUNCTION public.trg_bolsapunto_calc();

CREATE OR REPLACE FUNCTION public.trg_bolsapunto_calc()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_asignado_calc integer := 0;
BEGIN
  IF NEW.puntaje_utilizado IS NULL THEN NEW.puntaje_utilizado := 0; END IF;

  IF TG_OP = 'INSERT' THEN
    IF NEW.puntaje_asignado IS NULL THEN
      NEW.puntaje_asignado := fn_calc_puntos_por_monto(NEW.monto_operacion);
    END IF;
  ELSIF TG_OP = 'UPDATE' THEN
    IF (NEW.monto_operacion IS DISTINCT FROM OLD.monto_operacion) THEN
      v_asignado_calc := fn_calc_puntos_por_monto(NEW.monto_operacion);
      IF v_asignado_calc < COALESCE(NEW.puntaje_utilizado,0) THEN
        RAISE EXCEPTION
          'El nuevo puntaje asignado (%) por el monto % no puede ser menor que el ya utilizado (%)',
          v_asignado_calc, NEW.monto_operacion, NEW.puntaje_utilizado
          USING ERRCODE = '23514';
      END IF;
      NEW.puntaje_asignado := v_asignado_calc;
    END IF;
  END IF;

  IF COALESCE(NEW.puntaje_asignado,0) < 0 THEN
    RAISE EXCEPTION 'puntaje_asignado no puede ser negativo' USING ERRCODE = '23514';
  END IF;
  IF COALESCE(NEW.puntaje_utilizado,0) < 0 THEN
    RAISE EXCEPTION 'puntaje_utilizado no puede ser negativo' USING ERRCODE = '23514';
  END IF;
  IF COALESCE(NEW.puntaje_utilizado,0) > COALESCE(NEW.puntaje_asignado,0) THEN
    RAISE EXCEPTION 'puntaje_utilizado (%) no puede superar puntaje_asignado (%)',
      NEW.puntaje_utilizado, NEW.puntaje_asignado USING ERRCODE = '23514';
  END IF;

  NEW.saldo_punto := GREATEST(COALESCE(NEW.puntaje_asignado,0) - COALESCE(NEW.puntaje_utilizado,0), 0);
  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_bolsapunto_calc() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_bolsapunto_calc() TO postgres;

-- DROP FUNCTION public.trg_bolsapunto_integridad();

CREATE OR REPLACE FUNCTION public.trg_bolsapunto_integridad()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' THEN
    NEW.puntaje_utilizado := COALESCE(NEW.puntaje_utilizado, 0);
    NEW.puntaje_asignado := COALESCE(NEW.puntaje_asignado, 0);
    NEW.saldo_punto      := COALESCE(NEW.saldo_punto, NEW.puntaje_asignado - NEW.puntaje_utilizado);
  ELSE
    -- UPDATE: recalcular saldo siempre
    NEW.puntaje_utilizado := COALESCE(NEW.puntaje_utilizado, 0);
    NEW.puntaje_asignado := COALESCE(NEW.puntaje_asignado, 0);
    NEW.saldo_punto := NEW.puntaje_asignado - NEW.puntaje_utilizado;
  END IF;

  IF NEW.puntaje_asignado < 0 THEN
    RAISE EXCEPTION 'puntaje_asignado no puede ser negativo';
  END IF;
  IF NEW.puntaje_utilizado < 0 THEN
    RAISE EXCEPTION 'puntaje_utilizado no puede ser negativo';
  END IF;
  IF NEW.saldo_punto < 0 THEN
    RAISE EXCEPTION 'saldo_punto no puede quedar negativo';
  END IF;

  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_bolsapunto_integridad() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_bolsapunto_integridad() TO postgres;

-- DROP FUNCTION public.trg_cliente_validate();

CREATE OR REPLACE FUNCTION public.trg_cliente_validate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_exists int;
BEGIN
  -- Campos obligatorios
  IF TG_OP IN ('INSERT','UPDATE') THEN
    IF coalesce(NEW.nombre, '') = '' THEN
      RAISE EXCEPTION 'cliente.nombre es obligatorio';
    END IF;
    IF coalesce(NEW.apellido, '') = '' THEN
      RAISE EXCEPTION 'cliente.apellido es obligatorio';
    END IF;
    IF coalesce(NEW.numero_documento, '') = '' THEN
      RAISE EXCEPTION 'cliente.numero_documento es obligatorio';
    END IF;
    IF NEW.cod_tipo_documento IS NULL THEN
      RAISE EXCEPTION 'cliente.cod_tipo_documento es obligatorio';
    END IF;
    IF NEW.cod_nacionalidad IS NULL THEN
      RAISE EXCEPTION 'cliente.cod_nacionalidad es obligatorio';
    END IF;
    IF coalesce(NEW.email, '') = '' OR NOT fn_is_valid_email(NEW.email) THEN
      RAISE EXCEPTION 'cliente.email inválido';
    END IF;

    IF NEW.fecha_nacimiento IS NOT NULL AND NEW.fecha_nacimiento > current_date THEN
      RAISE EXCEPTION 'cliente.fecha_nacimiento no puede ser futura';
    END IF;

    -- Unicidad (cod_tipo_documento, numero_documento)
    SELECT 1
      INTO v_exists
      FROM cliente c
     WHERE c.cod_tipo_documento = NEW.cod_tipo_documento
       AND c.numero_documento = NEW.numero_documento
       AND c.id <> coalesce(NEW.id, -1)
     LIMIT 1;

    IF v_exists = 1 THEN
      RAISE EXCEPTION 'Existe ya un cliente con ese tipo de documento y número';
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_cliente_validate() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_cliente_validate() TO postgres;

-- DROP FUNCTION public.trg_conceptopunto_validate();

CREATE OR REPLACE FUNCTION public.trg_conceptopunto_validate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF coalesce(NEW.concepto, '') = '' THEN
    RAISE EXCEPTION 'conceptopunto.concepto es obligatorio';
  END IF;
  IF NEW.punto_requerido IS NULL OR NEW.punto_requerido <= 0 THEN
    RAISE EXCEPTION 'conceptopunto.punto_requerido debe ser > 0';
  END IF;
  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_conceptopunto_validate() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_conceptopunto_validate() TO postgres;

-- DROP FUNCTION public.trg_regla_validate();

CREATE OR REPLACE FUNCTION public.trg_regla_validate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_overlap int;
BEGIN
  -- Coherencia de rangos si ambos están informados
  IF NEW.limite_inferior IS NOT NULL AND NEW.limite_superior IS NOT NULL
     AND NEW.limite_inferior > NEW.limite_superior THEN
    RAISE EXCEPTION 'Rango inválido: limite_inferior > limite_superior';
  END IF;

  -- Valores positivos
  IF NEW.monto_equivalente IS NULL OR NEW.monto_equivalente <= 0 THEN
    RAISE EXCEPTION 'monto_equivalente debe ser > 0';
  END IF;
  IF NEW.punto_equivalente IS NULL OR NEW.punto_equivalente <= 0 THEN
    RAISE EXCEPTION 'punto_equivalente debe ser > 0';
  END IF;

  -- No solapamiento con otras reglas
  SELECT 1 INTO v_overlap
  FROM reglaasignacionpunto r
  WHERE r.id <> COALESCE(NEW.id, -1)
    AND (COALESCE(NEW.limite_inferior, -2147483648) <= COALESCE(r.limite_superior, 2147483647))
    AND (COALESCE(NEW.limite_superior, 2147483647) >= COALESCE(r.limite_inferior, -2147483648))
  LIMIT 1;

  IF v_overlap = 1 THEN
    RAISE EXCEPTION 'La nueva regla solapa con una existente';
  END IF;

  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_regla_validate() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_regla_validate() TO postgres;

-- DROP FUNCTION public.trg_upcase_cliente();

CREATE OR REPLACE FUNCTION public.trg_upcase_cliente()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.nombre           := fn_upper_if_not_null(NEW.nombre);
  NEW.apellido         := fn_upper_if_not_null(NEW.apellido);
  NEW.numero_documento := fn_upper_if_not_null(NEW.numero_documento);
  NEW.celular          := fn_upper_if_not_null(NEW.celular);
  NEW.email            := fn_lower_if_not_null(NEW.email);
  RETURN NEW;
END; $function$
;

-- Permissions

ALTER FUNCTION public.trg_upcase_cliente() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_upcase_cliente() TO postgres;

-- DROP FUNCTION public.trg_upcase_conceptopunto();

CREATE OR REPLACE FUNCTION public.trg_upcase_conceptopunto()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.concepto := fn_upper_if_not_null(NEW.concepto);
  RETURN NEW;
END; $function$
;

-- Permissions

ALTER FUNCTION public.trg_upcase_conceptopunto() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_upcase_conceptopunto() TO postgres;

-- DROP FUNCTION public.trg_upcase_nacionalidades();

CREATE OR REPLACE FUNCTION public.trg_upcase_nacionalidades()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.nacionalidad := fn_upper_if_not_null(NEW.nacionalidad);
  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_upcase_nacionalidades() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_upcase_nacionalidades() TO postgres;

-- DROP FUNCTION public.trg_upcase_paises();

CREATE OR REPLACE FUNCTION public.trg_upcase_paises()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.abreviatura := fn_upper_if_not_null(NEW.abreviatura);
  NEW.descripcion := fn_upper_if_not_null(NEW.descripcion);
  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_upcase_paises() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_upcase_paises() TO postgres;

-- DROP FUNCTION public.trg_upcase_tipos_documentos();

CREATE OR REPLACE FUNCTION public.trg_upcase_tipos_documentos()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.descripcion := fn_upper_if_not_null(NEW.descripcion);
  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_upcase_tipos_documentos() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_upcase_tipos_documentos() TO postgres;

-- DROP FUNCTION public.trg_usopuntocabecera_refund_exact();

CREATE OR REPLACE FUNCTION public.trg_usopuntocabecera_refund_exact()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  drec record;
  v_new_utilizado int;
BEGIN
  -- Recorrer todos los detalles de la cabecera
  FOR drec IN
    SELECT idbolsapunto, puntos_consumidos
      FROM usopuntodetalle
     WHERE idusopuntocabecera = OLD.id
  LOOP
    -- Devolver a la bolsa
    UPDATE bolsapunto
       SET puntaje_utilizado = GREATEST(puntaje_utilizado - drec.puntos_consumidos, 0),
           saldo_punto       = LEAST(puntaje_asignado,
                                     (puntaje_asignado - GREATEST(puntaje_utilizado - drec.puntos_consumidos, 0)))
     WHERE id = drec.idbolsapunto;
  END LOOP;

  -- Borrar el detalle de la cabecera
  DELETE FROM usopuntodetalle
   WHERE idusopuntocabecera = OLD.id;

  -- Continuar con el borrado de la cabecera
  RETURN OLD;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_usopuntocabecera_refund_exact() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_usopuntocabecera_refund_exact() TO postgres;

-- DROP FUNCTION public.trg_usopuntocabecera_revert();

CREATE OR REPLACE FUNCTION public.trg_usopuntocabecera_revert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  rec record;
BEGIN
  FOR rec IN
    SELECT ud.idbolsapunto, ud.puntos_consumidos
    FROM usopuntodetalle ud
    WHERE ud.idusopuntocabecera = OLD.id
  LOOP
    UPDATE bolsapunto
       SET puntaje_utilizado = puntaje_utilizado - rec.puntos_consumidos,
           saldo_punto = saldo_punto + rec.puntos_consumidos
     WHERE id = rec.idbolsapunto;
  END LOOP;

  DELETE FROM usopuntodetalle WHERE idusopuntocabecera = OLD.id;
  RETURN OLD;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_usopuntocabecera_revert() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_usopuntocabecera_revert() TO postgres;

-- DROP FUNCTION public.trg_usopuntocabecera_validate();

CREATE OR REPLACE FUNCTION public.trg_usopuntocabecera_validate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_req int;
  v_dispo int;
  v_ausar int;
BEGIN
  IF NEW.idconceptopunto IS NULL OR NEW.idcliente IS NULL THEN
    RAISE EXCEPTION 'idcliente e idconceptopunto son obligatorios';
  END IF;

  SELECT punto_requerido INTO v_req
  FROM conceptopunto WHERE id = NEW.idconceptopunto;

  IF v_req IS NULL OR v_req <= 0 THEN
    RAISE EXCEPTION 'Concepto inválido o sin punto_requerido > 0';
  END IF;

  v_ausar := COALESCE(NEW.puntaje_utilizado, v_req);
  IF v_ausar <= 0 THEN
    RAISE EXCEPTION 'puntaje_utilizado debe ser > 0';
  END IF;

  v_dispo := fn_total_saldo_disponible(NEW.idcliente);
  IF v_dispo < v_ausar THEN
    RAISE EXCEPTION 'Saldo insuficiente: disponible %, requerido %', v_dispo, v_ausar;
  END IF;

  -- Asegurar fecha
  IF NEW.fecha IS NULL THEN
    NEW.fecha := current_date;
  END IF;

  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_usopuntocabecera_validate() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_usopuntocabecera_validate() TO postgres;

-- DROP FUNCTION public.trg_usopuntodetalle_validate();

CREATE OR REPLACE FUNCTION public.trg_usopuntodetalle_validate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_fin date;
BEGIN
  IF NEW.idbolsapunto IS NULL THEN
    RAISE EXCEPTION 'idbolsapunto es obligatorio';
  END IF;

  SELECT v.fecha_fin
    INTO v_fin
    FROM bolsapunto b
    LEFT JOIN vencimientopunto v ON v.id = b.idvencimientopunto
   WHERE b.id = NEW.idbolsapunto;

  IF v_fin IS NOT NULL AND v_fin < current_date THEN
    RAISE EXCEPTION 'No se puede usar una bolsa vencida';
  END IF;

  -- Para nuevos consumos exigimos > 0
  IF TG_OP = 'INSERT' THEN
    IF NEW.puntos_consumidos IS NULL OR NEW.puntos_consumidos <= 0 THEN
      RAISE EXCEPTION 'puntos_consumidos debe ser > 0';
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_usopuntodetalle_validate() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_usopuntodetalle_validate() TO postgres;

-- DROP FUNCTION public.trg_vencimientopunto_validate();

CREATE OR REPLACE FUNCTION public.trg_vencimientopunto_validate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_diff int;
BEGIN
  IF NEW.fecha_inicio IS NOT NULL AND NEW.fecha_fin IS NOT NULL THEN
    IF NEW.fecha_inicio > NEW.fecha_fin THEN
      RAISE EXCEPTION 'fecha_inicio no puede ser mayor que fecha_fin';
    END IF;
    v_diff := (NEW.fecha_fin - NEW.fecha_inicio) + 1;
    IF NEW.dias_validez IS NOT NULL AND NEW.dias_validez <> v_diff THEN
      RAISE EXCEPTION 'dias_validez debe coincidir con (fecha_fin - fecha_inicio + 1)';
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
;

-- Permissions

ALTER FUNCTION public.trg_vencimientopunto_validate() OWNER TO postgres;
GRANT ALL ON FUNCTION public.trg_vencimientopunto_validate() TO postgres;


-- Permissions

GRANT ALL ON SCHEMA public TO pg_database_owner;
GRANT USAGE ON SCHEMA public TO public;